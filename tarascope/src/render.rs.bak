use std::{
    cell::RefCell,
    fs::{File, create_dir},
    io::{self, BufRead, BufReader, BufWriter, PipeReader, Write, pipe},
    process::{Child, Command, ExitStatus, Stdio},
    rc::Rc,
    thread::{self, JoinHandle},
};

use base64::{Engine, prelude::BASE64_STANDARD};
use command_fds::{CommandFdExt, FdMapping};
use serde::{Deserialize, Serialize};
use tempfile::NamedTempFile;

use crate::shader::KaleidoArgs;

enum BlenderCommand {
    Animated,
}

type PendingBlenderCommand = (Child, PipeReader);

#[derive(Serialize, Deserialize, Debug)]
pub struct RenderStatus {
    pub id: String,
    pub status: u32,
}

pub struct KaleidoOutput {
    //pub exit_status: ExitStatus,
    _output_directory: String,

    _stdout_reader: JoinHandle<()>,
    _stderr_reader: JoinHandle<()>,
    _status_reader: JoinHandle<()>,
}

impl KaleidoOutput {
    pub fn new(cmd: BlenderCommand, kargs: &KaleidoArgs) -> Self {
        let mut pending = cmd.run(kargs).unwrap();

        let stdout = pending.0.stdout.take().expect("failed to capture stdout");
        let stderr = pending.0.stderr.take().expect("failed to capture stderr");

        let output_dir = format!("{}/{}", kargs.get_output_dir(), kargs.get_id());

        let _stdout_reader = thread::spawn(move || {
            let mut log = File::create(format!("{}/blender.stdout.log", output_dir))
                .expect("failed to create output log");
            for line in BufReader::new(stdout).lines() {
                let l = line.unwrap();
                println!("[stdout] {}", l);
                log.write_all(l.as_bytes())
                    .expect("error writing to output log");
            }
        });

        let output_dir = format!("{}/{}", kargs.get_output_dir(), kargs.get_id());

        let _stderr_reader = thread::spawn(move || {
            let mut log_err = File::create(format!("{}/blender.stderr.log", output_dir))
                .expect("failed to create output error log");
            for line in BufReader::new(stderr).lines() {
                let l = line.unwrap();
                eprintln!("[stderr] {}", l);
                log_err
                    .write_all(l.as_bytes())
                    .expect("error writing to output log");
            }
        });

        let _status_reader = thread::spawn(move || {
            for line in BufReader::new(pending.1).lines() {
                let l = line.unwrap();

                let status = serde_json::from_str::<RenderStatus>(l.as_str()).unwrap();
                println!("[status] {:?}", status);

                //log.write_all(l.as_bytes()).expect("error writing to output log");
            }
        });

        Self {
            //exit_status: ,
            _output_directory: format!("{}/{}", kargs.get_output_dir(), kargs.get_id()),
            _stdout_reader,
            _stderr_reader,
            _status_reader,
        }
    }
}

pub fn run_kaleidoscope(args: &KaleidoArgs) -> io::Result<KaleidoOutput> {
    // wait until the render has finished
    //let output = child.wait_with_output()?;
    // extract Project File to a temporary location which gets dropped after the job is done
    let project_file = extract_static_file(BLEND_FILE)?;
    let project_borrow = project_file.borrow_mut();
    let project_path = project_borrow.path();

    // same with the loader file
    let loader_file = extract_static_file(PYTHON_LOADER)?;
    let loader_borrow = loader_file.borrow_mut();
    let loader_path = loader_borrow.path();

    // Encode the parameters to base64
    let parameters = BASE64_STANDARD.encode(args.json().to_string());

    // create the target project
    create_dir(format!("{}/{}", args.get_output_dir(), args.get_id()))
        .expect("couldn't create project dir");

    // write the parameters before the render begins
    let json = serde_json::to_string(&args.json()).unwrap();
    let mut file = File::create(format!(
        "{}/{}/parameters.json",
        args.get_output_dir(),
        args.get_id()
    ))?;
    file.write_all(json.as_bytes())?;

    let (reader, writer) = pipe().unwrap();

    let mut cmd = Command::new(BLENDER_PATH)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        // Map the return file descriptor to the Subprocess
        .fd_mappings(vec![FdMapping {
            parent_fd: writer.into(),
            child_fd: 7,
        }])
        .unwrap()
        .arg(project_path.as_os_str())
        .arg("--factory-startup")
        .arg("--log-file")
        .arg(format!(
            "{}/{}/blender.log",
            args.get_output_dir(),
            args.get_id()
        ))
        .arg("-o")
        .arg(format!(
            "{}/{}/frame_#####",
            args.get_output_dir(),
            args.get_id()
        ))
        .arg("-Y")
        .arg("-P")
        .arg(loader_path.as_os_str());

    let mut cmd = Command::new(BLENDER_PATH)
        //.arg("kaleido.blend")
        .arg("-s")
        .arg(args.get_start_frame().to_string())
        .arg("-e")
        .arg(args.get_end_frame().to_string())
        //.arg("loader.py")
        .arg("-f")
        .arg("0")
        .arg("-b")
        .arg("-a")
        .arg("--")
        //.arg(format!("{}", writer_fd))
        .arg(parameters);

    let child = cmd.spawn().unwrap();

    //Ok((child.spawn().expect("error while spawning child"), reader))

    let stdout = child.stdout.take().expect("failed to capture stdout");
    let stderr = child.stderr.take().expect("failed to capture stderr");

    let output_dir = format!("{}/{}", args.get_output_dir(), args.get_id());

    let stdout_reader = thread::spawn(move || {
        let mut log = File::create(format!("{}/blender.stdout.log", output_dir))
            .expect("failed to create output log");
        for line in BufReader::new(stdout).lines() {
            let l = line.unwrap();
            println!("[stdout] {}", l);
            log.write_all(l.as_bytes())
                .expect("error writing to output log");
        }
    });

    let output_dir = format!("{}/{}", args.get_output_dir(), args.get_id());
    let stderr_reader = thread::spawn(move || {
        let mut log_err = File::create(format!("{}/blender.stderr.log", output_dir))
            .expect("failed to create output error log");
        for line in BufReader::new(stderr).lines() {
            let l = line.unwrap();
            eprintln!("[stderr] {}", l);
            log_err
                .write_all(l.as_bytes())
                .expect("error writing to output log");
        }
    });

    for line in BufReader::new(reader).lines() {
        let l = line.unwrap();

        let status = serde_json::from_str::<RenderStatus>(l.as_str()).unwrap();
        println!("[status] {:?}", status);

        //log.write_all(l.as_bytes()).expect("error writing to output log");
    }

    //event_reader.join().unwrap();
    stdout_reader.join().unwrap();
    stderr_reader.join().unwrap();

    let output = child.wait()?;

    // TODO write stdout
    /*let mut log = File::create(format!("{}/{}/blender.stdout.log", args.get_output_dir(), args.get_id()))?;
    log.write_all(&output.stdout)?;
    log.flush()?;

    // TODO write stderr
    let mut log_err = File::create(format!("{}/{}/blender.stderr.log", args.get_output_dir(), args.get_id()))?;
    log_err.write_all(&output.stderr)?;
    log_err.flush()?;*/

    //Ok(output.status)
    Ok(KaleidoOutput::new(output, args.get_output_dir()))
}

#[cfg(target_os = "macos")]
static BLENDER_PATH: &str = "/Applications/Blender.app/Contents/MacOS/Blender";

#[cfg(target_os = "linux")]
static BLENDER_PATH: &str = "blender";

#[cfg(target_os = "windows")]
static BLENDER_PATH: &str = "C:\\Program Files\\Blender Foundation\\Blender\\blender.exe";

fn extract_static_file(buffer: &[u8]) -> io::Result<Rc<RefCell<NamedTempFile>>> {
    let blend_tmp = Rc::new(RefCell::new(NamedTempFile::new()?));
    {
        let mut b = blend_tmp.borrow_mut();
        let mut writer = BufWriter::new(b.as_file_mut());
        writer.write(buffer)?;
    }
    Ok(blend_tmp)
}

static BLEND_FILE: &[u8] = include_bytes!("../kaleido.blend");
static PYTHON_LOADER: &[u8] = include_bytes!("../loader.py");
